// Copyright (c) 2011 NVIDIA Corporation. All rights reserved.
//
// TO  THE MAXIMUM  EXTENT PERMITTED  BY APPLICABLE  LAW, THIS SOFTWARE  IS PROVIDED
// *AS IS*  AND NVIDIA AND  ITS SUPPLIERS DISCLAIM  ALL WARRANTIES,  EITHER  EXPRESS
// OR IMPLIED, INCLUDING, BUT NOT LIMITED  TO, NONINFRINGEMENT,IMPLIED WARRANTIES OF
// MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.  IN NO EVENT SHALL  NVIDIA 
// OR ITS SUPPLIERS BE  LIABLE  FOR  ANY  DIRECT, SPECIAL,  INCIDENTAL,  INDIRECT,  OR  
// CONSEQUENTIAL DAMAGES WHATSOEVER (INCLUDING, WITHOUT LIMITATION,  DAMAGES FOR LOSS 
// OF BUSINESS PROFITS, BUSINESS INTERRUPTION, LOSS OF BUSINESS INFORMATION, OR ANY 
// OTHER PECUNIARY LOSS) ARISING OUT OF THE  USE OF OR INABILITY  TO USE THIS SOFTWARE, 
// EVEN IF NVIDIA HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.
//
// Please direct any bugs or questions to SDKFeedback@nvidia.com

#ifndef _OCEAN_SIMULATOR_H
#define _OCEAN_SIMULATOR_H

#include "CommonInclude.h"
#include "wiGraphicsAPI.h"
#include "wiFFTGenerator.h"

#include <vector>

//#define CS_DEBUG_BUFFER

struct Camera;

struct wiOceanParameter
{
	// Must be power of 2.
	int dmap_dim;
	// Typical value is 1000 ~ 2000
	float patch_length;

	// Adjust the time interval for simulation.
	float time_scale;
	// Amplitude for transverse wave. Around 1.0
	float wave_amplitude;
	// Wind direction. Normalization not required.
	XMFLOAT2 wind_dir;
	// Around 100 ~ 1000
	float wind_speed;
	// This value damps out the waves against the wind direction.
	// Smaller value means higher wind dependency.
	float wind_dependency;
	// The amplitude for longitudinal wave. Must be positive.
	float choppy_scale;

	wiOceanParameter()
	{
		dmap_dim = 512;
		patch_length = 2000.0f;
		time_scale = 0.8f;
		wave_amplitude = 0.35f;
		wind_dir = XMFLOAT2(0.8f, 0.6f);
		wind_speed = 600.0f;
		wind_dependency = 0.07f;
		choppy_scale = 1.3f;
	}
};


class wiOcean
{
public:
	wiOcean(const wiOceanParameter& params);
	~wiOcean();

	// -------------------------- Initialization & simulation routines ------------------------

	// Update ocean wave when tick arrives.
	void updateDisplacementMap(float time);

	// Texture access
	wiGraphicsTypes::Texture2D* getDisplacementMap();
	wiGraphicsTypes::Texture2D* getGradientMap();

	const wiOceanParameter& getParameters();

	void Render(const Camera* camera, float time);


protected:
	wiOceanParameter m_param;

	// Simulation params: 

	wiGraphicsTypes::Texture2D* m_pDisplacementMap;		// (RGBA32F)
	wiGraphicsTypes::Texture2D* m_pGradientMap;			// (RGBA16F)

	// Initialize the vector field.
	void initHeightMap(XMFLOAT2* out_h0, float* out_omega);


	// ----------------------------------- CS simulation data ---------------------------------

	// Initial height field H(0) generated by Phillips spectrum & Gauss distribution.
	wiGraphicsTypes::GPUBuffer* m_pBuffer_Float2_H0;

	// Angular frequency
	wiGraphicsTypes::GPUBuffer* m_pBuffer_Float_Omega;

	// Height field H(t), choppy field Dx(t) and Dy(t) in frequency domain, updated each frame.
	wiGraphicsTypes::GPUBuffer* m_pBuffer_Float2_Ht;

	// Height & choppy buffer in the space domain, corresponding to H(t), Dx(t) and Dy(t)
	wiGraphicsTypes::GPUBuffer* m_pBuffer_Float_Dxyz;

	wiGraphicsTypes::GPUBuffer* m_pQuadVB;

	// Shaders, layouts and constants
	wiGraphicsTypes::ComputeShader* m_pUpdateSpectrumCS;

	wiGraphicsTypes::VertexShader* m_pQuadVS;
	wiGraphicsTypes::PixelShader* m_pUpdateDisplacementPS;
	wiGraphicsTypes::PixelShader* m_pGenGradientFoldingPS;

	wiGraphicsTypes::VertexLayout* m_pQuadLayout;

	wiGraphicsTypes::GPUBuffer* m_pImmutableCB;
	wiGraphicsTypes::GPUBuffer* m_pPerFrameCB;

	wiGraphicsTypes::Sampler m_pPointSamplerState;

	// FFT wrap-up
	CSFFT512x512_Plan m_fft_plan;

#ifdef CS_DEBUG_BUFFER
	wiGraphicsTypes::GPUBuffer* m_pDebugBuffer;
#endif



	// Rendering params:
	struct ocean_vertex
	{
		float index_x;
		float index_y;
	};

	// Mesh properties:

	// Mesh grid dimension, must be 2^n. 4x4 ~ 256x256
	int g_MeshDim = 128;
	// Side length of square shaped mesh patch
	float g_PatchLength;
	// Dimension of displacement map
	int g_DisplaceMapDim;
	// Subdivision thredshold. Any quad covers more pixels than this value needs to be subdivided.
	float g_UpperGridCoverage = 64.0f;
	// Draw distance = g_PatchLength * 2^g_FurthestCover
	int g_FurthestCover = 8;


	// Shading properties:
	// Two colors for waterbody and sky color
	XMFLOAT3 g_SkyColor = XMFLOAT3(0.38f, 0.45f, 0.56f);
	XMFLOAT3 g_WaterbodyColor = XMFLOAT3(0.07f, 0.15f, 0.2f);
	// Blending term for sky cubemap
	float g_SkyBlending = 16.0f;

	// Perlin wave parameters
	float g_PerlinSize = 1.0f;
	float g_PerlinSpeed = 0.06f;
	XMFLOAT3 g_PerlinAmplitude = XMFLOAT3(35, 42, 57);
	XMFLOAT3 g_PerlinGradient = XMFLOAT3(1.4f, 1.6f, 2.2f);
	XMFLOAT3 g_PerlinOctave = XMFLOAT3(1.12f, 0.59f, 0.23f);
	XMFLOAT2 g_WindDir;

	XMFLOAT3 g_BendParam = XMFLOAT3(0.1f, -0.4f, 0.2f);

	// Sunspot parameters
	XMFLOAT3 g_SunDir = XMFLOAT3(0.936016f, -0.343206f, 0.0780013f);
	XMFLOAT3 g_SunColor = XMFLOAT3(1.0f, 1.0f, 0.6f);
	float g_Shineness = 400.0f;




	struct QuadNode
	{
		XMFLOAT2 bottom_left;
		float length;
		int lod;

		int sub_node[4];
	};

	struct QuadRenderParam
	{
		UINT num_inner_verts;
		UINT num_inner_faces;
		UINT inner_start_index;

		UINT num_boundary_verts;
		UINT num_boundary_faces;
		UINT boundary_start_index;
	};

	// Quad-tree LOD, 0 to 9 (1x1 ~ 512x512) 
	int g_Lods = 0;
	// Pattern lookup array. Filled at init time.
	QuadRenderParam g_mesh_patterns[9][3][3][3][3];
	// Pick a proper mesh pattern according to the adjacent patches.
	QuadRenderParam& selectMeshPattern(const QuadNode& quad_node);

	// Rendering list
	std::vector<QuadNode> g_render_list;
	int buildNodeList(QuadNode& quad_node, const Camera& camera);

	// D3D11 buffers and layout
	wiGraphicsTypes::GPUBuffer* g_pMeshVB = nullptr;
	wiGraphicsTypes::GPUBuffer* g_pMeshIB = nullptr;
	wiGraphicsTypes::VertexLayout* g_pMeshLayout = nullptr;

	// Color look up 1D texture
	wiGraphicsTypes::Texture1D* g_pFresnelMap = nullptr;

	// Distant perlin wave
	wiGraphicsTypes::Texture2D* g_pPerlinMap = nullptr;

	// HLSL shaders
	wiGraphicsTypes::VertexShader* g_pOceanSurfVS = nullptr;
	wiGraphicsTypes::PixelShader* g_pOceanSurfPS = nullptr;
	wiGraphicsTypes::PixelShader* g_pWireframePS = nullptr;

	wiGraphicsTypes::GPUBuffer* g_pPerCallCB = nullptr;
	wiGraphicsTypes::GPUBuffer* g_pPerFrameCB = nullptr;
	wiGraphicsTypes::GPUBuffer* g_pShadingCB = nullptr;

	// State blocks
	wiGraphicsTypes::RasterizerState* g_pRSState_Solid = nullptr;
	wiGraphicsTypes::RasterizerState* g_pRSState_Wireframe = nullptr;
	wiGraphicsTypes::DepthStencilState* g_pDSState_Disable = nullptr;
	wiGraphicsTypes::BlendState* g_pBState_Transparent = nullptr;


	// init & cleanup
	void initRenderResource();
	void cleanupRenderResource();
	// create a triangle strip mesh for ocean surface.
	void createSurfaceMesh();
	// create color/fresnel lookup table.
	void createFresnelMap();
	// create perlin noise texture for far-sight rendering
	void loadTextures();

	int generateBoundaryMesh(int left_degree, int right_degree, int bottom_degree, int top_degree,
		RECT vert_rect, DWORD* output);
	int generateInnerMesh(RECT vert_rect, DWORD* output);
	bool checkNodeVisibility(const QuadNode& quad_node, const Camera& camera);
	float estimateGridCoverage(const QuadNode& quad_node, const Camera& camera, float screen_area);
	bool isLeaf(const QuadNode& quad_node);
	int searchLeaf(const std::vector<QuadNode>& node_list, const XMFLOAT2& point);
};

#endif	// _OCEAN_SIMULATOR_H
